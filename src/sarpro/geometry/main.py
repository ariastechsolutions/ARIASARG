import rasterio
from sarpro.utils.general import (
    get_array_backend,
    align_raster_to_reference,
    generate_blocks 
)
from sarpro.geometry.transforms import( 
    calculate_geometric_factor ,
    apply_rtc_correction 
)
from sarpro.geometry.rpc_utils import (
    normalize_coordinates,)

def compute_geometric_factor_raster(
    eia_path: str,
    lia_path: str,
    output_path: str,
    block_size: int = 4096,
    verbose: bool = True
) -> None:
    """
    Compute RTC geometric factor raster from EIA and LIA inputs.
    
    This function:
    1. Aligns EIA raster to LIA geometry
    2. Processes in blocks for memory efficiency
    3. Computes geometric factor: sin(LIA) / sin(EIA)
    4. Writes output as Float32 GeoTIFF
    
    Parameters
    ----------
    eia_path : str
        Path to Ellipsoid Incidence Angle raster (degrees)
    lia_path : str
        Path to Local Incidence Angle raster (radians)
    output_path : str
        Path for output geometric factor raster
    block_size : int, optional
        Processing block size in pixels (default: 4096)
    verbose : bool, optional
        Print progress messages (default: True)
    
    Example
    -------
    >>> compute_geometric_factor_raster(
    ...     eia_path='ellipsoid_incidence.tif',
    ...     lia_path='local_incidence.tif',
    ...     output_path='geometric_factor.tif'
    ... )
    """
    import time
    
    # Get computation backend
    cp, use_gpu = get_array_backend()
    if verbose:
        backend = "GPU (CuPy)" if use_gpu else "CPU (NumPy)"
        print(f"Using {backend} for computation")
    
    # Open LIA as reference for alignment
    with rasterio.open(lia_path) as src_lia:
        
        profile = src_lia.profile.copy()
        width = src_lia.width
        height = src_lia.height
        
        profile.update({
            'dtype': rasterio.float32,
            'count': 1,
            'compress': 'lzw',
            'nodata': 0.0,
            'BIGTIFF': 'YES'
        })
        
        if verbose:
            print(f"Processing {width}x{height} raster")
            print("Aligning EIA to LIA geometry...")
        
        # Align EIA to LIA
        with align_raster_to_reference(eia_path, src_lia) as src_eia:
            
            start_time = time.time()
            
            with rasterio.open(output_path, 'w', **profile) as dst:
                
                # Process in blocks
                for window, block_num, total_blocks in generate_blocks(width, height, block_size):
                    
                    # Read data
                    eia_data = src_eia.read(1, window=window)
                    lia_data = src_lia.read(1, window=window)
                    
                    # Transfer to GPU/CPU
                    eia_array = cp.asarray(eia_data, dtype=cp.float32)
                    lia_array = cp.asarray(lia_data, dtype=cp.float32)
                    
                    # Calculate geometric factor
                    ratio = calculate_geometric_factor(eia_array, lia_array, array_module=cp)
                    
                    # Write result
                    dst.write(cp.asnumpy(ratio), 1, window=window)
                    
                    if verbose:
                        print(f"Processed block {block_num}/{total_blocks}", end='\r')
            
            if verbose:
                elapsed = time.time() - start_time
                print(f"\nCompleted in {elapsed:.2f}s")
                print(f"Output saved to: {output_path}")


def apply_rtc_to_raster(
    sar_path: str,
    geometric_factor_path: str,
    k_factor: float,
    output_path: str,
    output_db: bool = False,
    block_size: int = 4096,
    verbose: bool = True
) -> None:
    """
    Apply Radiometric Terrain Correction to SAR imagery.
    
    This function applies RTC using a pre-computed geometric factor raster
    (typically generated by compute_geometric_factor_raster).
    
    Process:
    1. Align geometric factor to SAR geometry
    2. Process in blocks for memory efficiency
    3. Convert DN to sigma0: (DN^2 / K) * geometric_factor
    4. Optionally output in dB scale
    
    Parameters
    ----------
    sar_path : str
            
    geometric_factor_path : str
        Path to geometric factor raster (from compute_geometric_factor_raster)
    k_factor : float
        Sensor calibration constant (sensor-specific)
    output_path : str
        Path for output RTC-corrected raster
    output_db : bool, optional
        If True, output in dB scale (10*log10). Default: False (linear)
    block_size : int, optional
        Processing block size in pixels (default: 4096)
    verbose : bool, optional
        Print progress messages (default: True)
    
    Returns
    -------
    None
        Writes corrected raster to output_path
    
    Example
    -------
    >>> apply_rtc_to_raster(
    ...     sar_path='raw_sar.tif',
    ...     geometric_factor_path='geometric_factor.tif',
    ...     k_factor=1000.0,
    ...     output_path='rtc_corrected.tif',
    ...     output_db=True
    ... )
    
    Notes
    -----
    The K factor is sensor-specific:
    - ICEYE: typically around 1000-2000
    - Sentinel-1: varies by product type
    Check sensor documentation for correct value.
    """
    import time
    
    # Get computation backend
    cp, use_gpu = get_array_backend()
    if verbose:
        backend = "GPU (CuPy)" if use_gpu else "CPU (NumPy)"
        print(f"Using {backend} for computation")
    
    # Open SAR as reference
    with rasterio.open(sar_path) as src_sar:
        
        profile = src_sar.profile.copy()
        width = src_sar.width
        height = src_sar.height
        
        # Set nodata based on output format
        nodata_value = -99.0 if output_db else 0.0
        
        profile.update({
            'dtype': rasterio.float32,
            'count': 1,
            'compress': 'lzw',
            'nodata': nodata_value,
            'BIGTIFF': 'YES'
        })
        
        if verbose:
            print(f"Processing {width}x{height} raster")
            print(f"Calibration Factor K: {k_factor}")
            output_mode = "dB" if output_db else "linear"
            print(f"Output mode: {output_mode}")
            print("Aligning geometric factor to SAR geometry...")
        
        # Align geometric factor to SAR
        with align_raster_to_reference(geometric_factor_path, src_sar) as src_ratio:
            
            start_time = time.time()
            
            with rasterio.open(output_path, 'w', **profile) as dst:
                
                # Process in blocks
                for window, block_num, total_blocks in generate_blocks(width, height, block_size):
                    
                    # Read data
                    sar_data = src_sar.read(1, window=window)
                    ratio_data = src_ratio.read(1, window=window)
                    
                    # Transfer to GPU/CPU
                    sar_array = cp.asarray(sar_data, dtype=cp.float32)
                    ratio_array = cp.asarray(ratio_data, dtype=cp.float32)
                    
                    # Apply RTC correction
                    rtc_corrected = apply_rtc_correction(
                        sar_array,
                        ratio_array,
                        k_factor,
                        output_db=output_db,
                        array_module=cp
                    )
                    
                    # Write result
                    dst.write(cp.asnumpy(rtc_corrected), 1, window=window)
                    
                    if verbose:
                        print(f"Processed block {block_num}/{total_blocks}", end='\r')
            
            if verbose:
                elapsed = time.time() - start_time
                print(f"\nCompleted in {elapsed:.2f}s")
                print(f"Output saved to: {output_path}")





